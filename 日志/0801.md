# 大晴

> 本周末真是有史以来最认真的周末了~ 日均学习 5 h, 进步显著, 主要得益于以下原因

1. 开始注意了大块时间的使用 - 以前都会找借口用娱乐把时间切割, 这次早上下午晚上都**保证了大块时间的完整度**, 没有任性的去切割时间, 大块的时间一旦切开, 就散了(也就是没了)
2. 减少大量无效信息的输入, 内心也做到了平静, 表现得很好
3. 主观意识上的跟随了内心, 心生欢喜, 不要为了娱乐而娱乐, 跟随内心, 做自己想做的事情
4. 一天的时间真的没有想象那么多, 这样比较满意的一天也才花了 5 h, 看起来一天只会睡 8 h 还剩下, 16 h, 都被切割的零零散散, 能捡起来的时间也就那么几大块, 所以一定要格外珍惜那几大块的时间啊. 
5. 当然了, 学习有趣, 但也只是生活的一部分, 平衡学习, 健康, 和愉悦的内心, 岂不美哉

# 学习了

## 使用闭包

1. **私有变量**是什么, js 原生支持吗 ? 如何用闭包实现近似的, 可接受的私有变量 ?
   1. 在构造函数内使用私有变量, 我们可以通过闭包内部方法获取到私有变量, **不能再外部直接访问** 可以有效阻止对变量不可控的修改.
2. 回调函数应用闭包 - 通常在回调中, 我们通常需要频繁访问外部数据, 如果没有闭包将会多些很多代码
   1. 闭包的存在可以将内存值, 在回调中直接使用

## 通过执行上下文跟踪代码

> js 如何跟踪函数执行, 并回到函数对应位置?

1. 请注意 **函数上下文** 和 **函数执行上下文** 的区别? 请说出不同
   1. 函数上下文: 就是函数的 this, 表示谁调用了函数
   2. 函数执行上下文: js 内部概念, js引擎用其来跟踪函数执行
2. 代码分两种: 全局代码, 函数代码, 对应的执行上下文也分: 全局执行上下文, 函数执行上下文
   1. js 中的每一行代码都运行在特定上下文中
   2. 简单理解就是代码的执行环境 - 个人理解
   3. 当调用新函数, 当前执行上下文要 **停止** , 并且**创建新函数的执行上下文来执行新函数**, 当新函数执行完毕, 销毁它的执行上下文, 并且回到最初的执行上下文
3. js 跟踪执行上下文的变化用的是什么方法
   1. 用的 **执行上下文栈** (或调用栈 call stack - chrome里面可以查看)
   2. 请详述调用栈的工作方式 - 顶部插入/推出 直到结束

## 词法环境

> 词法环境是 js 作用域的内部实现机制, 也就是 **作用域**  **词法环境是函数调用时创建的**

1. 每次调用一个函数, 都会创建一个新的 **词法环境** - **作用域**, js 通过作用域来判断他能访问哪些 变量
2. 代码会一直循着作用域链寻找, 直到全局, 找不到会报错
3. **每个执行上下文都关联一个词法环境** 该词法环境包含: 在该上下文定义的标识符映射表
4. **调用函数时候,会创建一个对应的词法环境(作用域), 并存在内部属性 `[[environment]]`** 上` p.103`



## let  const var

1. const 变量只能声明一次, 以后不好在变, 所以 const 必须带初始值, const不可重新赋值, 但是可以对对象或者数组进行修改操作, 只要不是重新赋值
2. let 声明的变量可以多次变更, var也是
3. var 定义变量时候, 是在最近的函数内部, 或者全局词法环境, var会略块级作用域
4. let const会在最近的词法环境中定义变量, 包括块级作用域



## 如何在词法环境中注册标识符 p.112

在创建了新的词法环境后会发生:

1. 不执行代码, js 引擎会扫描当前作用域下声明的变量(包括 var let const)和函数, 并且注册该标识符

2. 具体后面的执行会取决于 声明变量的类型和函数声明, 以及代码环境(块级作用域)
   1. 如果是全局或者函数环境
      1. 扫描代码, 并进行函数声明 (不扫描箭头函数或者函数表达式) -> 创建函数, 绑定到之前注册的



## 生成器

> 当生成器生成一个值, 不像普通函数停止, 而是挂起

1. 如何定义一个生成器

   1. 在 function后面加一个`*`
   2. 这样生成器函数体中就可以使用 `yield`
   3. For-of 可以用来循环迭代器

2. 调用生成器函数不会执行代码, 会生成一个叫做迭代器的对象

   1. 迭代器可以控制生成器代码的执行 - 使用 `.next()`

   2. 调用该方法后: 生成器执行到 `yield` 会生成一个中间结果, 放在一个对象中返回

      ```js
      {
        value: 'bar',
        done: false / true
      }
      ```

   3. 生成结果后会非阻塞的挂起, 随后等待下一次请求

   4. next 方法会让生成器 从挂起到唤醒, 会继续从上次执行完的位置, 继续执行

   5. 当执行到最后会返回 value: undefined, done: true, 表示迭代完成

3. 生成器的应用

   1. 尝试写出 for-of 迭代生成器的原理
   2. 可以在生成器中,  field 另一个生成器(), 此时会在这个生成器上进行迭代
   3. 使用生成器生成ID序列 - 写出来
   4. 使用 生成器遍历 DOM 树

4. 生成器可以传参, `.next` 也可以传参, 传入的参数会变成 yield 表达式的值, 继续执行 `p.137`

5. 迭代器上 `throw` 方法的使用 - 改善一步服务器通信

