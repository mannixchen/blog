

# 阴 -> 多云

> 踏实, 一点
>
> 那些所谓的 rss 订阅对我并没有帮助, 只会干扰方向, 我只要按照既定路线往前走就好了 steady

# 学习了

## 原始值, 引用值

> 引用值是保存在内存中的对象, js 不允许访问内存位置, 因此也就不能直接操作 对象所在的内存空间, 操作对象时候, 实际上操作的是对该对象的引用

### 动态属性

引用值可以动态添加属性

### 复制值

原始值会被复制到新的变量位置, 两个变量独立使用, 互不干扰

引用值, 复制的是指向对象的指针

### 传递参数

所有参数都是按值传递

1. 原始类型就传递的原始类型
2. 引用类型传递的一个指针, 虽然按值传递, 但值本身就是一个指针

### 确定类型

typeof 可以确定原始类型和函数类型 (typeof fn -> 根据是否实现了 [[call]] 方法, 有该方法的对象就会返回 'function')

不可确定对象 和 null

instanceof 可以确定对象是什么类型的对象 (根据构造函数的原型在不在目标对象的原型链上) 用 instanceof 检测原始值, 始终返回 false, 因为原始值不是对象



## 执行上下文和作用域

> 函数执行上下文 + 词法环境

1. 函数所在的函数执行上下文决定了他能访问哪些数据, 每个执行上下人都关联一个**活动对象**, 这个上下文中所有变量函数都在上面 (用户无法访问, ECMAScript 后台可以用到它)
2. 全局上下文在浏览器中就是 window 对象 (var定义的会变成 window 的属性和方法, let const 定义的不会出现在全局上下文中, 但是在作用域链解析上效果和var 一样)
3. 函数执行上下文执行完所有代码会被销毁, 包括定义在里面的所有变量和函数
4. js程序的执行流是通过 函数执行上下文栈控制的
5. 当上下文代码执行时候, 会创建变量对象的作用域链, 当前函数的 **活动对象** 用作其变量对象, 变量对象最初只有 arguments 一个属性(全局上下文没有) , 其包含该函数的包含上下文会变成作用域的下一个变量对象, 以此类推, 最终到全局上下文, 作用域链的确定是函数定义时候确定的确定的, 在函数执行时候产生的
6. 上下文之间的连接是线性的
7. 函数参数就相当于函数执行上下文中的变量



