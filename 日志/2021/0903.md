

# 阴 -> 晴

> 出天隆寺吃饭, 听书, 跳出大脑 (其实不就是正念吗, 不与烦恼做斗争, 和它共生, 继续做自己的事情, 泰然自若)



# 学习了

## 垃圾回收

### 内存管理

1. 分配给浏览器的内存比桌面软件少很多, 分配给移动浏览器的内存更加少, 完全处于安全考虑, 害怕网页消耗太多内存导致系统奔溃` p97`
2. 对于不再需要的数据可以将其设置为 null, 释放其引用 (适用于全局对象 全局对象的属性)
3. 优先使用 const let, 这不仅仅有助于改善代码风格, 还有助于改进垃圾回收的进程, 在块级作用域更早终止的情况下, 垃圾回收可以更早的介入, 回收内存
4. 共享相同隐藏类对象的性能会更好
   1. 避免先创建后填补, 可以在构造函数中一次性声明所有属性
   2. 不要随意删除已有属性, 最佳实践是把不想要的属性设置为 null, 这样是为了保持隐藏类不变, 并且继续共享

### 内存泄漏

1. 大多由不合理的引用导致
2. 意外声明全局变量
3. 闭包也会无意中造成内存泄露

**静态分配, 对象池**

> 通过手段间接控制触发垃圾回收的条件, 合理使用分配内存, 避免多余的垃圾回收, 就可以保住因为释放内存而损失的性能

1. 当发现对象更快的更替, 就会更加频繁的触发垃圾回收, 
2. 所以问题是怎么创建才能不让垃圾回收盯上
3. `p101` 属于过早优化, 因此不用考虑

## 基本引用类型



### Date

> 参考的早期 `Java` 中的 `java.util.Date` , date 类型将日期保存为 UTC 类型 从 1970-1-1零点所经历的毫秒数, 可以精准表示以后的 28 万年

1. `new Date()` 不传参默认表示当前事件

2. 要基于其他时间需要传入对应的毫秒数, 如果不是毫秒数, date 构造函数**会根据情况调用 `Date.parse() / Date.UTC()` 方法, 自动转换成时间戳再进行时间生成**

3. Date.parse(): 可以传四种格式

   ![image-20210903234522566](https://raw.githubusercontent.com/mannixchan/Pics/master/img/image-20210903234522566.png)

4. Date.UTC()

   ![image-20210903234605211](https://raw.githubusercontent.com/mannixchan/Pics/master/img/image-20210903234605211.png)

   要注意的是该方法月份和小时的表达是从 0 开始计算的, **在 Date 隐式调用 Date.UTC() 方法时, 会保存为本地时间格式, 不是 GMT 格式 **



![image-20210903235234098](https://raw.githubusercontent.com/mannixchan/Pics/master/img/image-20210903235234098.png)

UTC是最新全球时间标准, 更准确,  GMT 是根据地球自转计算, UTC 是根据原子钟计算, 不与时区挂钩, 默认为 0 时区时间, 

GMT = UTC + 0 // 格林尼治

CST = UTC + 8 = GMT + 8// 北京时间 东 八

![image-20210903235954523](https://raw.githubusercontent.com/mannixchan/Pics/master/img/image-20210903235954523.png)

5. Date.now() 返回当前的时间戳, 可以用于代码分析