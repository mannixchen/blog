# 大雨

> 今天还是被外界干扰了思绪, 内心也一度陷入焦躁
>
> 关键点还是那些: **减少非必要信息摄入, 专注于当下, 简洁生活, 内心平静, 事随心动**

# 学习了

## 计时器 - 延迟器/间隔器 p342

> 应用得当可以开发复杂应用, 计时器能延迟一段代码执行, 延长时间  **至少** 是指定时长

1. 计时器是宿主环境提供的 (浏览器 / node), 不是 js 本身定义的, 事件循环是 js 自带的
2. 两种创建计时器的方法, setTimeout/setInterval, 还提供两种清除计时器的方法, clearTimeout/clearInterval, 这些方法都挂在在 window 对象上
3. 创建计时器会返回标识计时器的唯一值, 可以用 clearTimeout/clearInterval 来取消该计时器
4. 大部分浏览器都允许使用 clearTimeout/clearInterval 取消任意类型的计时器, 但是为了语义化清晰化, 不建议这么用
5. 计时器的延迟事件没法具体保证
6. 我们只能控制计时器事件**何时会被加入到队列**, 无法控制什么时候执行
7. 延时器递归和间隔器的不同 p348



## setTimeout(fn, ms)

> 延迟计时器会在创建ms秒后把 fn 函数推到宏队列上去, 并且等前面的宏任务都执行完之后再执行 fn



## setInterval(fn, ms)

> 间隔计时器, 会每隔ms秒后尝试将 fn 推到宏任务队列中, 如果此时有该计时器的其他回调在宏任务队列等待执行, 那么这次尝试会被忽略取消, 正在执行的该计时器回调 / 没有回调在执行或者等待, 就会成功推入到宏任务队列 **也就是, 同一个宏任务队列不会存在超过1个正在等待的相同间隔器的事件**



## 用计时器进行复杂度高的任务

> 用大量插入dom的例子, 实现书里面的例子 p349

1. 将原来的一次性js操作, 通过延时器拆分成若干组分次执行, 从而不影响 UI 渲染
2. UI 需要等一次宏任务执行完才会进行一次 Ui渲染, 太久的单次宏任务会影响 Ui 渲染, 造成卡顿, 超过 5s 大部分浏览器都会提醒无响应
3. 所以分次生成不同的宏任务, 这样就能让 dom 进行分批插入, 而不会影响 UI渲染
4. 理解事件循环机制, 会让我们越过浏览器单线程的限制, 为用户提供更好的交互体验



## 事件

### 区分 事件回调里的 event.target 和 this

前者指向触发事件的元素, 后者指向事件绑定的元素, event 回调参数还包括许多其他事件相关信息



### 捕获与冒泡

> 捕获来自网景, 冒泡起源自微软

1. 现代浏览器都实现了捕获和冒泡
2. 任何一个事件发生都是先自上到下捕获, 到达目标元素后, 在自下及上进入捕获状态
3. 在使用 `addEventListener` 时候我们可以传入第三个参数控制事件触发的阶段(捕获/冒泡)
4. `true` 为捕获状态
5. `false` 为冒泡状态, 所以不传默认就是冒泡状态
6. 所以默认状态下 , A 包含 B, 点击 B 会先触发 B的事件函数, 然后也会触发 A 的事件函数, 再也会触发 `document` 的事件函数
7. 这个标准是由 `W3` 委员会设立的标准, 同时包含两种方式, 都被现代浏览器实现



### 在祖先元素上代理 p357

> 我们可以在祖先元素上创建事件, 来尽可能少的写相同构造的事件函数

>  具体怎么确定是哪个目标 dom 触发的呢? 通过 `event.target`, 再次回忆 它 和 this 的区别

 `event.target` 代表触发事件的目标dom, this表示绑定事件的 dom 元素, 我们可以根据  `event.target`, 确定具体的目标 dom



### 自定义事件

> 怎么创建松耦合的自定义事件 p358

**关键点**

1. new CustomEvent()
2. dispatchEvent()
3. 明天手动实现一下 自定义事件案例



