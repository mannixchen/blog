# 阴

> 今天上班效率一般, 但是也有所收获
>
> 回家之后, 略显疲惫, 多休息了一会儿, 看书效率自然也不高, 看了跑马拉松相关的电影, 也让我回忆起跑步的快乐了, 希望以后跑步可以继续跑起来
>
> 关于今晚的效率, 确实疲惫的身躯需要休息. 这对自己也是一种好事, 让自己处于一个舒适的环境下会更有利于学习
>
> 这也提醒我, 要适当改变作息了, 也要适当的运动了, 自己的精气神确实是差一些了

# 学习了

## 编译正则表达式

> 处理正则表达式经历多个阶段, 其中主要的是 **编译和执行**

1. 编译发生在正则表达式被创建时期, 执行发生在使用编译后的正则表达式进行匹配字符串时期
   1. 编译: js 引擎会解析表达式, 转为内部代码 这些步骤发生在创建时期
   2. 通过事先定义正则, 可以使性能得到提升, 将正则表达式保存在变量中是重要的优化过程
2. 常用的 正则实例有 **test, exec** 方法
   1. **test**: 参数是一个字符串, 判断该字符串是否满足该正则表达式, 返回 **true, false**
3. 通过构造函数可以创建动态的正则表达式 `p268`
4. :speech_balloon: **在字符串中想要使用反斜线, 就需要先使用反斜线进行转义**, 所以在使用构造函数传入字符串也要注意这点
5. 正则表达式中 圆括号 具有两个功能 **分组和捕获** 可以把捕获当成 想获得的指定规则的字符串片段
6. 字符串的 **match** 方法 (布局匹配)
   1. 参数是一个正则表达式, 返回是 null(匹配失败) 或者数组(匹配成功)
   2. arr[0], 是匹配成功的第一个值
   3. arr[1], 是匹配到的第一个捕获
   4. 递增.... 捕获
7.  **match** 方法 (全局匹配)
   1. 全局匹配使用 match, 不会返回捕获, 只会返回所有匹配结果的列表
8. 如果想要全局匹配, 并且获得捕获, 可以多次对一个正则调用 **exec** 方法
   1. 每次调用都会返回下一个匹配项的结果, 该结果类型同 **match** 方法 (布局匹配)
   2. 这个方法会保留前一次的调用的结果, 这样再次调用就可以匹配下一次的匹配结果了

## 总结 正则在 js 中的使用

```js
/**
* 按照执行对象
* 正则实例上的方法: exec, test
* 字符串上的方法: match
* 按照功能
* 判断字符串是否符合该正则: /reg/.test(str)
* 想要获得第一个匹配项, 以及对应的捕获: str.match(/reg/)
* 想获得多个匹配项: str.match(/reg/g) - 全局使用 match 匹配
* 想要找到一个个的匹配项和捕获: /reg/g.exec(str) - 没执行一次, 就会获得下一个匹配项和捕获结果的数组
*/
```

