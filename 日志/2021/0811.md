# 阴 -> 雨

> 好不容易跑步, 不容易, 现在11点有点困, 晚上虽然效率一般, 但是也没有直接的浪费什么时间, 希望明天早些起来, 多看一会儿

# 学习了

## 代码模块化

> 小的, 组织良好的代码会更容易理解, 更容易维护, 怎么去优化一个程序的结构和组织方式, **就是把他们分成小的, 耦合相对松散的片段**

### 立即执行函数和闭包 p285

> es 6之前我们利用对象, 立即函数, 闭包开发出了高级模块化技术

每个模块系统至少需要以下操作

1. 定义模块接口, 供调用
2. 隐藏模块的内部实现, 使用者无需关注内部实现, 同时隐藏内部实现, 可以避免有可能产生副作用

:speech_balloon: **隐藏实现细节, 定义模块接口**

隐藏内部实现

1. 用函数创建新的作用域, 在作用域中定义变量, 仅仅模块自身(当前函数)可见, 所以由于作用域, **选择用函数作为模块**

定义模块接口

1. 为了方便其他代码调用模块, 我们要定义简洁的接口, 通过接口暴露功能, 我们实现方式就是利用对象和闭包, **通过函数模块返回公共接口对象** 这个对象提供模块提供的方法, 而这些方法通过闭包访问内部定义的变量



**用函数定义模块, 立即执行, 返回对象 - 接口**

### 扩展模块

> 可以不改动原有模块的代码

1. 调用立即执行函数, 传入模块, 对module操作, 最后还是 返回 module
2. 缺点: 无法模块的私有变量, 因为每个函数都创建了新的作用域

### AMD

> amd 设计理念是明显基于浏览器, 而commonjs是基于 js 环境 (如 Node环境), 不限于浏览器

```js
/** 
* 1. 新创建模块的 ID , 使用该 ID, 可以在系统的其他部分引用该 模块
* 2. 当前模块依赖的 ID 列表 数组
* 3. 初始化模块的工厂函数, 接受以来的模块列表作为参数
*/
define('module', ['jQuery'], $ => {
  //操作
  return {
    //接口对象, 暴露公共接口
  }
})

// 在amd请求模块的时候, 这个过程是异步的, 避免堵塞, 所有模块下载好了, 并且解析完成, 才会调用回调函数, 并将模块作为参数传入函数
```

优点:

1. 自动处理依赖, 无需考虑依赖顺序
2. 异步加载模块, 避免阻塞
3. 可以在文件上定义多个模块



### CommonJS

> 一个文件是一个模块, 文件的代码是模块的一部分, 不需要用立即执行函数包装变量, 在模块中定义的变量都会安全的包含在模块中, 不会暴露到全局作用域 - **模块有自己的作用域, 不会污染全局**

1. 只有通过 `module.exports` 暴露的对象或者函数才可以在模块外使用, 无需返回一个全新的对象, 模块已经提供了扩展接口和属性的方法

   ```js
   module.exports = {}
   //或
   exports.name = 'jjjj'
   
   ```

2. Common JS 是 node 的默认模块格式, 可以随时使用 npm 上的包

3. 缺点: 不显示支持浏览器, 浏览器js 不支持 module 和exports属性, 借助 Browserify 和 RequireJS 可以完成相应支持

### UMD

> 一种模块解决方案, 自动选择对应模块



### ES6

> 结合了 CommonJS 和 AMD 的优点

1. 语法简单, 基于文件 - CommonJS
2. 支持模块异步加载 - AMD

**主要思想**

> 显示的使用标识符导出模块, 才可以从外部访问模块, 其他标识符, 都只能在模块内部访问, 这点收到 CommonJS 启发

1. 单个导出标识符

   ```js
   export const message = 'Hello'
   export function sayHi () {
     ...
   }
   ```

   

2. 批量一起导出导出

   ```js
   const message = 'Hello'
   function sayHi () {
     ...
   }
   export {message, sayHi}
   ```

   

3. 导入命名导出

   ```js
   import {message, sayHi} from './js.js'
   ```

   

4. 用别名导入全部标识符

   ```js
   import * as bundle from './js'
   // 用 * 导入全部标识符, 一定要指定 别名
   ```

   

5. 默认导出

   ```js
   export default class Ninja {}
   ```

   

6. 默认导出 同时加 命名导出

   ```js
   export default class Ninja {}
   export function name() {}
   ```

   

7. 导入默认导出不需要使用 `{}`

   ```js
   import custimizeName from 'js'
   // 接受默认导出, 随意用变量
   ```

   

8. 同时导入命名导出和默认导出的方法

   ```js
   // 1
   import customize from 'js'
   import {name} from 'js'
   //2
   import customize, {name} from 'js'
   ```

   

9. 导入导出重命名

   ```js
   export {name as joName} // as后面是别名, 必须用别名接受
   import {joName as name} from 'js' // as 后面是别名, 在提供上下文更加合适的名字时候, 避免命名冲突可以使用 as 别名
   ```

   

## DOM

> 了解类库的代码原理: **1. 可以配合类库写出更加高效的代码  2. 可以将这些技术灵活用到自己的代码中**

1. 如果要设计一个 向dom中写入 html 的api 需要考虑一下
   1. 确保 html字符合法化
   2. 将它包裹在任意浏览器规则要求的闭合标签中
   3. 用 innerHTML 将 html插入到虚拟 dom元素
   4. 提取该dom







