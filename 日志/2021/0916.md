# 晴天





# 学习了

## 迭代器

### 自定义迭代器

1. 任何实现了 Iterable 接口的对象都可以用作迭代器 **p188**
2. 创建一个 Array 实例
   1. `arr[Symbol.iterator]() `返回的迭代器也拥有` [Symbol.iterator]`方法
   2. 并且该方法执行的结果执行的结果指向了第一个迭代器本身
   3. 换言之: 调用数组迭代器`let iter1 = arr[Symbol.iterator]` 的 `[Symbol.iterator]` 方法其实也是返回 `iter1` 自身
3. 在自定义的迭代器中, 可以定义一个 return ( ) 方法用于指定在迭代器关闭时执行的逻辑, 到底哪些方法可以 **关闭** 自定义迭代器呢
   1. for-of 循环的 break, continue, return 或 throw提前推出
   2. 结构操作没有消费所有值
   3. 这些操作都会调用定义的 return ( ) 方法
4. **正是 return ( ) 方法是可选的, 所以不是所有迭代器都支持关闭**, 可以测试迭代实例的 return 属性 是不是一个 **函数**, 不可以简单地给不可关闭的迭代器增加这个方法就让他变得可关闭, 虽说可以被调用, 但是却不会强制让迭代器关闭 **p191**
5. 比如数组的迭代器就没有默认关闭的功能



## 生成器

> 这是 ECMAScript 新增的一个极为灵活的结构, 可以在一个函数块内暂停恢复代码执行 (函数执行上下文的挂起和恢复执行)

**需要强调的是, 迭代对象包括了许多, 而生成器对象知识其中一种**

* 生成器的形式就是一个函数, 在函数名称前加上一个 ( * ) 号就表示这是一个生成器函数, 但凡可以定义函数的地方就可以定义生成器函数 ( 箭头函数除外 )

  ![image-20210916130650246](/Users/chenmingming/Library/Application Support/typora-user-images/image-20210916130650246.png)

* 标识生成器函数的 **星号** 不受两侧空格数量的影响, 空格请随意

* 调用生成器函数会得到一个 **生成器对象 ( 迭代器 )** , 其一开始时处于 **暂停 ( suspended )** 状态, 这个对象实现了 Iterator 接口, 调用 next ( ) 方法会让生成器开始或者恢复执行

* 调用 next ( ) 方法返回一个具有 done 和 value 属性的对象

* **生成器只会在初次调用 next ( ) 才开始执行**

## yield

> 这个关键字可以让生成器停止和开始执行, 生成器的核心关键字 **p194**

