# Java 基本程序设计结构

## 字符串

> 字符串是不可变的 - <核心技术 1> p.45

1. **截取字符串, 拼接字符串** - <核心技术 1> p.45

`substring` `join`

2. **检测字符串相等使用 `equals`**
3. **检测空串, null** - <核心技术 1> p.48

## 控制流程

1. **不要再嵌套的两个块中声明同名变量**

   ![image-20220902133927032](http://bucket-picbed.oss-cn-shanghai.aliyuncs.com/img/image-20220902133927032.png)



## 数组

1. **数组的创建** - <核心技术 1> p.79
2. **创建空数组时, 数组会有默认值** p.80

# 对象和类

> 对象变量没有实际包含一个对象, **它只是引用一个对象** - <核心技术 1> p.98

## 访问权限

1. `public` 意味着任何类的任何方法都可以调用这些方法
2. `private` 只有当前类的自身方法可以调用这些实例字段, 所以实例字段都标记为 `private`



## 自定义类

1. `this` 对象的 `this`  - <核心技术 1> p.111
2. 设置或获取一个实例字段  - <核心技术 1> p.112
3. **基于类的访问权限**
   1. 只要**属于同一个类**, 不同实例的方法可以访问不同实例的私有属性
4. **私有方法**
   1. 如果希望将计算代码分解成若干辅助方法, 可以设计成私有方法  - <核心技术 1> p.114
5. **final 字段** 
   1. 确保在构造器执行后, 该值已经被初始化
6. **静态字段, 静态方法**
   1. **每个实例都可以修改类字段, 所以最好不要有公共类字段, 但是可以有公共常量**
   2. 静态方法中**只能直接访问静态字段, 不可直接访问实例字段**, 静态方法没有 `this`
   3. 可以直接用实例来调用 **类方法** 但是这样容易造成混淆, 所以**不建议用实例来调用静态方法**
7. 方法参数
   1. **Java** 是按值调用



## 对象构造

1. 字段初始化
   1. 构造器没有显式赋值, 会有默认字段的初始化`0, false, null`  - <核心技术 1> p.127
   2. 初始化可以在定义类的时候赋值, 也可以在构造函数里面进行赋值
2. **在构造器中用 `this` 调用另一个构造器**  - <核心技术 1> p.129
   1. 此时 `this` 要放在第一行, 这样可以**复用公共的构造器代码**
3. 初始化块
   1. 在运行构造器之前, 会先运行初始化块
   2. 一般建议, 初始化块**总是放在字段定义之后**
   3. 声明字段和代码块有相同优先级, 按照出现顺序进行初始化
4. **构造对象的代码顺序**  - <核心技术 1> p.131



## 包

> 目的是确保类名的唯一性  - <核心技术 1> p.134

1. **一个类可以使用所属包的所有类, 以及其他包中的公共类**
2. 访问包的两种方式 (完全限定名, 以及`import` 语句)
3. 导入和静态导入  - <核心技术 1> p.136



# 继承

> 继承已存在的类就是复用这些类的方法, 并且可以增加一些新的方法和字段  - <核心技术 1> p.155

## 覆盖方法

1. 子类的方法不可以直接访问父类的私有字段
2. 可以借用公共的 `getter` 函数来进行获取, 并且将 `super` 作为引用超类方法的前缀



## 子类的构造器

1. `super()` 和方法中的 `super.` 有着不同的含义, 这里的 `super` 是对应构造器的简写  - <核心技术 1> p.158



## 多态

1. 类A声明一个变量a, 那么 a 既可以引用 类A, 也可以引用类A的子类, **类A的声明决定了当前变量 `a` 有哪些能力**, 而执行具体函数时候, `a` 调用的是真实引用的具体方法(**动态绑定技术**)  - <核心技术 1> p.159
2. 数组类型转换可能引起的报错  - <核心技术 1> p.163
3. 用 `final` 声明类和方法



## 类变量的强制类型转换

>  在强制类型转换之前, 先检查是否可以正常成功转换, 使用 `instanceof` - <核心技术 1> p.167

1. 只能在继承层次内进行强制类型转换
2. 尽量少用强制类型转换, 建议配合 `instanceof` 进行强制类型转换



## 抽象类

> `abstract` 修饰的方法不需要具体实现, **如果一旦类包含了一个及以上的抽象方法, 那么类也需要被定义为抽象的**

1. 即使不包含抽象方法, 也可以声明为抽象类  - <核心技术 1> p.170
2. **抽象类不能实例化**
3. 可以定义抽象类的对象变量



## 访问权限

1. private - 仅仅对本类可见
2. public - 对外部完全可见
3. protected - 对所有子类以及本包可见
4. 不需要修饰符 - 对本包可见



## toString 方法

> <核心技术 1> p.182

1. 数组使用 `Arrays.toString` 方法打印数组
2. 强烈建议给每个类都添加 `toString` 方法



## 泛型类

1. 声明一个泛型类  - <核心技术 1> p.187
2. 数组列表的声明和使用 (**add 和 set 的区别 **)



## 对象包装器和自动装箱

> 每个基础类型都由对应的 **包装类**

1. 泛型的类型参数不可以是基本类型, 而应该是包装类
2. 基本类型和其包装类型之间, 声明和值之间可以自动装箱拆箱
3. `null` 自动拆箱引发的空指针异常  - <核心技术 1> p.111



## 参数数量可变的方法

- <核心技术 1> p.196



## 枚举类

<核心技术 1> p.197



## 反射

<核心技术 1> p.198



# 接口 lambda表达式 内部类

## 接口

> 接口不是类, 而是一组需求

1. 接口中所有方法都自动是 `public`, 所以不用手动给关键字, **不过在实现方法时要将方法声明为 public** - <核心技术 1> p.224
2. 接口中绝不会有实力字段, Java8 之前也不会有实现的方法
3. 接口中的字段总是默认是 **public static final**, **java 语言规范建议不要提供多余的关键字**
4. java9 中开始可以在接口中声明 **private** 方法, 用作辅助方法 - <核心技术 1> p.230
5. 增加一个默认方法  - <核心技术 1> p.231
6. 在实现多个接口时候, **方法冲突时候的优先级**
7. 123456

