# 晴/阴

> 今天思考了

> 只有内心平静才能安心学习 -> 其实 **学习就是在想办法怎么让自己平静下来**

1. 减少干扰
2. 少表达, 少期待
3. 做人要低调 - 做事浮夸, 为人浮躁, 说话轻浮, 终究是无法获得内心的清净和宁和, 不适合学习
4. 怎么学习, 就是怎么去获得宁静, 内心宁静, 外界宁静
5. 或许自从初中毕业之后, 再没有宁静的做过事情了, 想想那年轻的时候, 能扎下心来学习的原因就是: 内心无挂碍, 生活简单, 及其低调(甚至沉闷, 甚至封闭自我)才能做到的吧
6. 让生活和行为贴近上面的准则



# 学习了

## 生成器的内部

> 执行生成器, 获得一个迭代器, 可以通过迭代器控制生成器的执行

1. 运行生成器, 都发生了什么
   1. 创建生成器, 挂起, return迭代器, 
   2. .next() 激活生成器, 挂起  -> 执行, 执行到 `yield` 继续挂起 返回对象 {value, done}
   3. .next() 再次激活, 挂起 -> 执行, 没有代码执行 或 执行到 return语句, 生成器就会标志完成状态, 返回指定对象
2. 执行上下文栈是如何跟踪生成器的
   1. 生成器本质还是函数, 所以会被调用栈跟踪
   2. 在调用生成器函数, 会创建一个新的生成器执行上下文, 放到调用栈的最上面
   3. 此时生成器不执行任何代码, 直接返回一个迭代器, 保存着生成器创建所产生的执行上下文
   4. 此时生成器上下文会从调用栈弹出, 直到调用 迭代器的 `next()` 方法
   5. 此方法会重新激活, 对应的执行上下文, 把它放到栈顶部, 并且从上次停止执行的地方, 继续执行
   6. 遇到 `yield`, 生成器会继续挂起, 并且返回该值





## Promise

### 创建一个简单地promise

1. 怎么创建一个 promise, 回调函数参数怎么传?
   1. 回调函数传什么参数, 分别是什么 ?
   2. 回调执行会传入 `resoleve` 和 `reject` 内置函数, 分别表示 `兑现` 和 `被拒绝`
   3. 此时会接收到一个 promise 对象, 可以调用 `.then()` 方法, 传入两个方法, 第一个为 resolve之后的回调, 第二个是reject后的回调

### 普通回调带来的问题

1. 为什么错误容易丢失(处理错误困难) - 调用回调代码一般和开始任务的代码不在事件循环的同一个步骤
2. 回调地狱
3. 执行并行任务麻烦棘手 - 要写很多重复代码, 仅仅为了执行多个行动



### 深入 promise

1. **promise 对象是用于异步任务结果的占位符**
2. 刚创建的promise 对象是 pending状态, 直到 resolve (完成 fulfill) 或者 reject/ 抛出错误(reject被拒绝)
3. 一旦 从 pending 到 **完成或者被拒绝**, 那么状态将无法再变
4. `promise` 的代码执行顺序
   1. 调用 promise构造函数创建一个对象, 他会立即调用传入的函数(同步), 此时处于 `pending` 状态 直到 resolve/reject
   2. 以网络请求为例, 请示请求已经发送, 在你调用 `.then()`时, 也许依然 `pending` 也有可能已经 `fulfill/reject`
   3. 如果还在pending, 那么就等待 resolve, 同时继续执行同步代码, 在得到兑现的时候, 调用 then里面的回调, 回调会被推到 `微任务队列`
   4. 如果已经 兑现, `.then()` 也不会立即执行回调, (但是会把回调推入微任务队列), 同时依然会等同步代码执行完毕, 再去微任务队列进行调用 - Promise设计就是用来处理异步任务, 
5. reject, 的回调可以用第二个回调参数, 也可以用`.catch`方法, 不论是 手动reject还是代码异常都会被 catch
6. **设计一个 getJson 方法 用promise封装请求**
7. `.then `  里面可以 return一个promise, 这样就可以链式调用, 代替回调地狱了, 请说出具体怎么实现
8. 等待多个 promise 任务
   1. `Promise.all` 方法, 可以等待多个 rpomise, 将一个 promise对象数组作为参数, 然后返回一个新的promise对象
   2. 当数组中的所有 promise都解决了, 这个返回的promise才会解决, 如果其中一个 promise 被拒绝, 那么新返回的 promise 也就被 拒绝 ( **但是可以确定的是, 数组里面的promise都得到了有效执行**)
   3. return 的成功值也是一个数组, 对应 promise 对象数组
9. 如果只关心第一个成功/失败的promise, 我们可以用 `Promise.race`
   1. 参数同上, 返回一个新的 promise
   2. 某个promise被处理或者拒绝, 那么这个新返回的promise就同样会被处理或者拒绝

