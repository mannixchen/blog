# 大晴 - 愉快学习, 缺乏运动

> 今天状态在近期算比较好, 比较优先级的将大块事件给了学习

> 许多时候觉得还没干什么, 一个上午就过去了

> 许多时候, 我就再多看一会儿视频, 再多玩一把游戏, 大块的时间就没了

> 很多时候, 我觉得念书是重要的, 但也偷偷觉得看会儿视频, 玩会儿游戏是无伤大雅的
>
> 但是因此早上还没干什么, 下午也没做什么, 晚上还没开始一天就结束了, 一天的时间其实没那么多

> 游戏和视频把时间片段化, 所以**最基本的是在一天的某些时间段是绝对不能娱乐的, 大块的时间被切割, 被娱乐拖延吞噬, 结果还没做什么, 一天就没了** 只要内心觉得要学, 是想学的, 这些时间就应该留给想学的事务
>
> 在另一些时间, 是可以娱乐的, 但请不要完成任务的去打游戏, 去看视频, 想玩是可以玩, 想读书那也就去读书, 累了自然可以休息一下. 愉快的放松, 那是最好的



# 学习了

## 实参和形参 - p51

1. 实参和形参分别是什么? 

   1. 形参: 与函数定义关联
   2. 实参: 与函数调用关联

2. 剩余参数是什么? 如何定义剩余参数?

   1. 只有函数的最后一个形参才能使剩余参数

3. 默认参数

   1. es5 中如何定义默认参数

      1. `typeof a === 'undefined' ? 'default' : a`

   2. Es6 直接在定义时, 参数用 `=` 号接默认参数

      1. 每次函数调用会从左到右求参数的值, 所以后面的参数, 可以直接引用前面的参数, 不推荐这种写法, 可读性不好

## 函数

> 理解 `arguments` 和 `this`, 这两个是函数调用时隐形传递的 `隐式参数` (arguments, 箭头函数不可用)

### arguments

> `arguments` 由函数调用时候决定

1. 有什么属性 ?  (callee, length), arguments 是什么数据格式 ? 其和剩余参数有什么区别? 
2. arguments 和 函数形参有什么关联 - 其可以作为函数参数的别名, 更改arguments[0] 会对应改变 第一个参数(严格模式无效) 他们是否访问同一内存地址, 是否保持同步? 
3. 阐述严格模式下 arguments 和 普通模式的区别
   1. 严格模式, arguments 不可以重写, 会报错
   2. 严格模式, 修改 arguments[0], 不会同步到第一个参数
   3. arguments 与调用有关联, 如果只传一个值, 更改 arguments[1] 是不会同步到第二个参数的
4. 为什么严格模式下不可以修改 arguments 同步到参数 ? - 因为其作为函数参数别名会影响代码的可读性
5. 严格模式怎么开启 ?

### this

> this 是函数默认隐藏参数, 代表函数调用相关联的对象

1. this 指向收到哪些因素影响
   1. 定义函数的方式 和 位置
   2. 调用方式



### 函数调用

1. 函数调用的四种方式

   1. 函数式调用
   2. 方法调用
   3. call , apply
   4. 作为构造函数调用
2. 作为函数被调用

   1. 通过()运算符直接调用, 并且不是作为对象属性, 就属于此
   2. `this` 有两种可能: 严格: undefined(因为并没有指定函数被调用的对象) 普通: window
3. 方法调用

   1. 当函数作为某个对象方法被调用时候, 该对象会成为`函数上下文`
4. 作为构造函数调用

   1. new 的时候发生了什么
      1. 创建新对象
      2. 把新对象作为函数的函数上下文: this
      3. 把函数的`protoType` 给到 对象的 `__proto__`
      4. 运行构造函数, 返回实例
   2. 如果你在构造函数中 `return 1` 会怎么样
      1. **无影响, 费对象类型, 都会忽略返回值, 返回的还是实例**
      2. **如果你返回的是一个对象, 那就回替代实例被返回**
5. apply 和 call
   1. 手动绑定函数上下文
   2. 在指定函数的一个上下文对象时候特别有用, 在执行回调时候经常用到 p.78
6. 如何解决函数上下文的问题
   1. 箭头函数 - **this 只跟定义位置的函数上下文有关**
      1. 箭头函数, 没有独立的 this值, 箭头函数的 `this` 和声明所在的上下文相同
      2. 调用箭头函数, 不会隐式传入 `this` 而是从定义时候的继承当前环境的函数上下文
      3. 如果用字面量创建一个带箭头函数的对象, 那箭头函数的 `this` 是对象还是`定义对象的函数上下文` 
         1. 因为箭头函数**作为字面量对象的属性值**跟着对象直接定义, 所以直接被定义在了当前函数上下文了, 而非对象
         2. 构造函数是执行的时候才会定义箭头函数, 彼时 this 是实例
7. bind
   1. bind 会创建一个新函数, 拥有相同的行为, 不同的内存
   2. 箭头函数, 不可以使用 `call apply bind`

### 闭包

> 可以减少代码数量, 添加高级功能 - 私有变量

1. 闭包是纯函数式语言的特性之一, 闭包也进入了主流开发语言, 可以大大简化复杂操做
2. 闭包带来的问题 - js的作用域如何工作
3. 闭包是什么, 怎么理解闭包
   1. 当在函数内部声明一个内部函数 **不仅顶一个函数的声明, 还创建了一个闭包**
   2. **这个闭包包含: 1. 函数的声明 2. 声明时候该作用域的所有变量** - 那可以理解为, 闭包就是里面的**函数 + 他所保留的整个作用域链**
   3. 缺点: 存储和引用这些信息会影响性能, 闭包有用, 但是不要过度使用, 会消耗内存, 直到关闭








​         