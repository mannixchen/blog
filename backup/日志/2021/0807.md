# 妥妥的多云

> 多余的信息, 和对社交的依赖都是在所难免的, 或多或少的会影响内心平和, 我需要做的就是尽快恢复内心, 放下这些萦绕在脑海的执念, 这些在寻求内心平静的过程中, 都是微不足道的

# 复习了

1. `script` 标签 的 `defer async` 属性的区别
2. 说出 for in , in 的作用, 对是否可遍历属性的接受程度, 是否包含原型上的属性

# 学习了

## getter, setter的应用场景 p207

1. 如何用 setter 做数据赋值验证, 怎么实现
2. 如何用 getter 计算属性值, 访问 getter setter 定义的属性和访问普通属性一样

## 如何使用 proxy 控制访问

> `proxy` 让我们可以通过 `代理` 控制对另一个对象的访问 可以理解为通用化的 getter setter, 

1. 如何创建代理, 说出具体操作, 传什么参数

   ```js
   const obj = {}
   // 传入 obj 对象, 以及包含 get, set 方法的对象, 用于处理属性读写工作
   const objProxy = new Proxy(obj, {
     get: (target, key) => { 
       return key in target ? target[key] : 'no property'
     },
     set: (target, key, value) => {
       target[key]=value
     }
   })
   
   // 直接 obj 访问属性, 无变化
   // 通过 代理 访问属性, 就会出发 定义好的处理方法
   
   
   ```

### 用代理记录日志

> 我们可以改变标识符的指向为 代理, 不要担心原本对象的状态, **原对象作为代理对象的 target , 会一直保持活跃**

> P214 

### 用代理检测性能

> 检测性能的目标一般是一个函数, **Proxy 可以代理函数, 因为函数本就是第一对象公民**

1. 调用函数代理, 会触发对象里的 `apply` 方法 , apply 的回调要传 3个参数 (target - 原函数, thisArg - 函数上下文, args - 传入的参数)p216
2. 在 apply 处理函数里面, 用 target.apply() , 执行
3. 实现 函数代理的案例, 测试函数的运行性能

### 自动填充属性

> 请实现, 场景: 假设你需要长路径文件模型, 如何自动填充属性

1. 涉及到:
   1. 构造函数 Folder, 创建代理, 递归构造函数
2. 实现不会动不动报错, undefined 或者 null



### 实现负数数组索引

> 实现类似 python ruby perl 的负数组功能

1. 实现负索引功能
2. 得到的另一个结论就是, 可以通过下标访问数组并且触发 get set了, 解决了 vue2 中的问题, Array 可以创建代理



### 性能问题

> 代理其实就是给所有的操作添加了一个间接层, 在实现很多功能的同时, 引入了大量的额外处理, 影响性能

1. 据测试, 代理数组在chrome下, 性能会差 50 倍
2. 所以在多次执行代码时, 要彻底的测试代码性能



## 处理集合

### 数组

> 说出数组的方法们, 举例说明

1. 创建数组的方式有哪些, 
   1. 构造函数
   2. 字面量 - 为什么更加推荐字面量, 因为 js 高度动态, Array 构造函数是可以被修改的, 你创建的 Array, 不一定是数组

2. 为什么访问, 数组长度之外的索引, 返回的是 `undefined`, 其他语言会抛出异常

   1. 这个特性表明, **数组就是对象** 访问不存在的对象属性, 就是返回 `undefined` , 这个特性就是继承自对象

3. 设置一个远大于 length 的数组索引值, **同时会改变数组长度, 并且中间的空元素都是 `undefined`**

4. 手动修改length, 数组会被扩展, 新扩展的元素 都是`undefined`, 设置为更小的数, 数组会被裁剪

5. **在数组的两端, 添加删除数组**

   1. **push**: 在后面加
   2. **pop**: 在后面减少
   3. **unshift**: 在前面加
   4. **shift**: 在前面减
   5. 在后面加减的性能要高于在前面操作的, 非特殊情况, 不建议使用 **unshift, shift**

6. **在数组的任意位置, 添加删除**

   ```js
   //splice - 改变原数组
   arr.splice(index)
   // 只传第一个参数, 从 index(包括)开始, 到最后的的元素都会被切割, 会返回被删除元素的合集, 同时改变原数组 
   arr.splice(index, num)
   // 从 index (包括) 开始, 切割 num 个元素, 返回切割的元素, 改变原数组
   arr.splice(index, num, arg1, arg2, arg3...)
   // 从 index (包括) 开始, 切割 num 个元素, 并将后面的元素, 按顺序插入到 index原来的位置
   
   ```

7. **forEach**

   1. for 循环的 `es6` 实现
   2. 会有 return 的问题, 只能 return 当前回调, 如果要退出整个循环, 还是要用 for

8. **映射数组 map()**

   1. 基于已有数组, 创建新数组
   2. 在新建的数组上, 会基于每次回调, 将 `return` 的值塞到对应的位置
   3. 原理就是 map 方法, 让数组的每个元素执行回调, 并用返回的值创建新数组

9. **测试数组 - every, some**

   1. every, 所有元素测试都满足(返回 true)才会返回 true, 否者有一个失败都会返回 false, 并停止后面的遍历
   2. some, 只要有一个测试满足就会返回 true, 并停止后面的继续测试

10. **数组查找 - find**

    1. find 方法会返回第一个满足条件的元素, **只会返回第一个符合的元素**, 找不到就是 undefined
    2. 要是想返回符合条件的集合 可以用 **filter** 方法, 他会返回一个符合条件的 **集合**
    3. 查找 **特定元素的索引** 可以使用数组的 **indexOf** 方法, 找不到就返回 `-1`, 找到就返回对应 index, 可以用 `> -1` 来确定数组是否包含该元素
    4. 查找最后一次元素出现的索引可以使用 **lastIndexOf** 使用同上
    5. 当不具备元素引用时候, 可以用 **findIndex** 方法, **返回第一个符合条件的 索引**,  找不到返回  `-1`

11. **数组排序 - sort方法**

    1. 数组调用 sort 方法传入回调, 参数是相邻的两个元素

       ```js
       // (a ,b) 为例
       1. 如果回调返回小于 0, a, b 不交换位置
       2. 返回 等于 0, a, b 保持位置
       3. 返回 大于 0, a, b 交换位置
       ```

    2. 字符串比大小, 比的是字母顺序

12. **合计数组元素 - reduce** 

    1. 案例, 对数组所有元素求和

       ```js
         /** reduce 方法优化
          * parameter1 : 为回调函数, 回调函数有两个参数 (1. 初始值(第二次开始就是上次回调返回的值) 2. 数组的每一项)
          * parameter2 : 初始值
          * 如果不传第二个参数, 默认以数组的第一项作为初始值, 第二项作为初始项
          */
       
       ```

13. **使用类数组对象 - 复用内置的数组函数**

    > 如何将数组方法实现为类数组的方法, 增加复用

    1. 给对象设置 length 属性, 请实现: 在类数组上实现 push 方法
       1. 注意用call 绑定 this
       2. 考察: 1. 可变函数上下文的能力 2. 复用已经编写的代码





