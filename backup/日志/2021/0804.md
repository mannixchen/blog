# 晴天

> 为什么要选择学习
>
> 那是因为, 我想学习, 我心里愿意学习, 也喜欢学习, 我知道这样是跟时间更好的相处方式, **我能真切的体验到时间**
>
> 而不是, 通过游戏, 综艺, 剧集, 挥霍时间, 获得短暂的快乐, 却失去了和时间的联系, **被吞噬时间留下的空白**是让人感觉空洞的, 也不幸福
>
> 今天下午对稍微制定了学习计划, 也幻想了很多未来的事宜, 想太多的未来确实是不好的, 会让内心无法宁静, 还是要保持内心的平静, 少接触花里胡哨的信息, 保持思想纯一

# 学习了

> 好好思考一下原型, 说出你对他的理解

1. js 原型主要为了 使用一种`类`风格的面向对象和继承的方式进行编码

2. 如何避免开发中重复代码, 继承就是代码复用的一种方式

3. 原型是什么: 每个对象都有原型(的引用), 当查找属性, 对象上没有属性, 就会查找原型上有没有

4. **`in`** 操作符

   > 可以判断对象是否具有某一个属性 (包括原型上的属性, 不可枚举的属性, 只要能访问到, 都返回 true)

5. 将一个对象设置为另一个对象的原型可以使用

   ```js
   Object.setPrototypeOf(target, proto) // 将 proto 设置为 target 的原型
   ```

6. js 查找属性是一个向上寻找的过程, 直到找完整个原型链, `实例 -> 原型 -> 原型的原型`, 直到没有更多原型

7. 每个函数都由 `prototype` 属性, 这个属性会变成 `new 对象` 的 `__proto__` 属性

8. 每个原型都由一个 `constructor` 属性, 指向(构造)函数本身, 

9. 实例会隐藏原型中和实例重名的方法

10. 实例属性放置方法会浪费大量内存 (创建私有变量需要这么写), 我们可以通过原型实现方法共享

11. **实例保持着创建时候的原型引用, 即使后来原型被重写(内存地址改变)**

12. `instanceof` 用来检测一个实例是否由特定的构造函数创建, 重写原型, 会让原型失去constructor, 可以用 `Object.definePropertyOf()` 重写, enumerable 设置为false, value设置为构造函数

13. 创建原型链可以把原型设置为另一个对象的实例

14. **`For-in`** 可以遍历**实例上可以遍历的属性以及原型上的属性**(只包含可枚举的, 不包括: 不可遍历), 相对应的 `Object.keys` **只可以枚举出 实例上可枚举的属性**

15. Constructor 可以用来确认创建对象的构造函数 `实例.constructor === Ninja`

16. **`instanceof`** 详解

    > `实例 instanceof Ninja` 判断的原理是: **Ninja的原型是否在 `实例` 的原型链上**, 他不是通过 `constructor` 属性来进行判断的哦

    > **检测右边值原型是否在左边值的原型链上**

    > :a: : **当心构造函数原型变化**, 在实例创建之后, 重写构造函数原型, 会导致检查失败, 因为新的函数原型, 已经不存在与之前创建的实例的原型链上了

