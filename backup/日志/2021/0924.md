# 晴



# 学习了

## 静态类方法

1. 静态类方法, 是恒定的, 不会因为实例化变多而有任何改变
2. 使用 static 作为前缀, 静态成员中, this 表示类自身
3. 其他约定和原型成员一致: 只能函数, 生成器, 支持get set
4. 静态类方法非常适合作为实例工厂 类似: Object.create( ) p256
5. **如果要在原型或类上添加共享数据成员, 需要在类定义外手动添加, 之所以麻烦是因为, 在共享目标(原型或类)上添加可变数据成员是一种反模式**
6. 类上支持在原型或类本身定义生成器, 所以可以把实例变成可迭代对象 (p257)



## 继承

> 是ECMAScript 6中新增特性最出色的特性: 原生支持类继承, 背后的原理依然是原型链

1. 使用 **extends** 关键字
2. 支持所有拥有 [[construct]] 和原型的对象, 所以支持继承普通构造函数 (向后兼容)
3. 派生类可以访问到父类原型和类上定义的方法, 也就是原型和静态方法都得到了继承
4. extends 可以用在表达式中

### 构造函数和 Super

1. **super** 只可以在派生类的构造函数和静态方法内部使用
2. super 引用父类的原型, 在类构造函数中使用 super 可以直接调用父类构造函数
3. HomeObject (p260)

#### super

1. 只能在类构造函数和静态方法中使用
2. 只可以用来调用构造函数, 或者引用静态方法
3. 直接 super () 会调用父类的构造函数, 并将返回的实例赋值给 this
4. 如果子类没有显式定义构造函数, 在实例化子类时候的参数, 都是默认传入给, 默认的 super () 调用
5. 在构造函数中, 不可以在 调用 super () 之前访问 this
6. 如果是显式的定义构造函数, 那么必须调用 super () 或者 返回一个对象, 要不会报错



#### 抽象基类

> 供其他类继承, 本身不会实例化

1. 使用 new.target  (构造函数内) 防止自身被实例化, 判断等不等于自身
2. 可以**用 this 判断子类原型上是否存在指定方法** (原因是: 在进入构造函数之前, this 的 `__proto__` 已经被赋值为 prototype, 此时 this 可以用来判断原型上的方法) (p262)

