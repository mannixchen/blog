# 晴, 大晴

> 最近工作总感觉少点什么, 激情 ?  方向 ?
>
> 买了七本书, 慢慢看, 慢慢看

# 学习了

## 作用域链增强

1. 执行上下文分全局上下文, 函数上下文两种, (eval调用内部存在第三种上下文)
2. 某些语句会导致在作用域链前段临时添加一个上下文, 这个上下文在代码执行后会被删除, 有两种情况
   1. try/catch的catch代码块
   2. with 语句
3. with 语句会向作用域链**前端添加指定的对象**
4. catch语句, 会创建一个新的变量对象, 这个变量对象包含抛出错误的声明



## 变量声明

### var声明

1. 变量会被自动添加到最接近的上下文(提升到最近函数作用域的顶部, 位于作用域中所有代码之前) 这个现象叫提升
2. 变量未经声明直接初始化, 会被自动添加到全局上下文 (严格模式下, 这样会报错)



### let

1. 块级作用域 {} 界定
2. var可以var两次, let不行
3. 循环中声明迭代变量推荐用 let
4. **let 也会被 JavaScript 运行 提升, 但是由于 暂时性死区的原因, 所以在声明之前不能够使用 let 变量** 但是从书写 js 的角度来看, let 和 var 的提升不一样



### const

1. 声明必须初始化
2. 不能重新赋值, 对对象的属性操作不限制
3. 如果想让整个对象都不能修改 可以使用 : `Object.freeze()`, 此时赋值不会报错, 但是静默失败
4. const 暗示变量单一类型不可修改,  所以js 编译器可以将其所有实例都替换成实际的值, 不会进行查询表进行变量查找, V8引擎就执行这种优化
5. 尽可能使用 const 声明, 从根本上保证提前发现重新赋值导致的bug



### 标识符查找

> 按照作用域链进行查找

1. 块级作用域不会改变搜索流程, 但是给词法层级添加了额外的层次
2. 访问局部变量比访问全局变量要快