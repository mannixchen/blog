# 晴

> 规律生活, 利用惯性来学习, 注意休息, 及时整理和复习, 不要接受无效信息

# 学习了

## Math

> 用来保存数学公式, 信息, 计算的地方, Math 提供的计算要比直接在 JavaScript 中实现的快, 因为使用了JavaScript 引擎中更高效的实现和处理器指令

### min () 和 max ()

> 确定一组数值中的最大最小值

要确定数组中最大 (小) 值, 直接在参数中展开就好



### 舍入

1. Math.ceil() 向上舍入
2. Math.floor() 向下舍入
3. Math.round() 四舍五入
4. Math.fround() 返回最接近的单精度 (32位) 的浮点数表示

### random()

> 返回 大于等于 0, 小于 1 的任意随机数, 可以应用于随机显示一个东西

如果想要去 1-10 的随机数, 可以这么写

`Math.floor(Math.random() * 10 + 1)`

如果想要为了加密生成随机数, 建议使用 `window.crypto.getRandomValues()`

Math 对于 正弦余弦正切等计算的实现取决于 浏览器, **所以这些计算的精确度因实现而异**



## 集合引用类型

### Object

> 很适合存储交和交换数据的一种数据格式

**声明的方式**

1. new Object() 构造函数创建
2. 字面量创建

- **当出现一个赋值符号时, 就生成一个表达式上下文 (表示期待返回一个值)**

- 当表达式上下文中出现了 **`{` 表示这是一个对象字面量的开始, 因为它出现在表达式上下文中**

- 如果这个 `{` 出现在 **语句上下文** 则表示这是一个代码块的开始

>  **构成**: 指定一个 name 属性, 后面跟一个冒号, 后面是属性值, 逗号用来分隔各个属性, **属性名可以是字符串或者一个数值**,**数值属性会自动转换成字符串**  归根结底, 属性本质上是一个字符串

- **在用对象字面量定义对象时候, 实际上不会调用 Object 构造函数**

- **最佳实践** 再给函数传递参数时候, 最好方式对于**必选参数, 使用命名参数, 而对象字面量可以封装多个可选参数进去** 
- 点语法是首选属性存取方式, 除非访问属性需要使用变量或特定类型字符串(如有空格), 则使用 **中括号语法**





### Array

#### 创建方式

1. 构造函数 new Array, 也可以省略 new 操作符 直接使用 Array, 
   1. 如果传一个数字,则创建一个包含指定数量元素的数组
   2. 如果传一串, 则创建指定元素的数组
2. 数组字面量 (**字面量创建数组, 不会调用 Array 构造函数, 所以安全, 不怕Array类型被修改**)

#### 静态方法

**from()**

1. 第一个参数是一个类数组对象, **任何迭代结构, 或者一个有length属性, 和可索引元素的结构**

   > Map, Set, 类数组对象, 任何用用 Symbol.iterator的对象, 都可以传入进去, 并创建一个新的数组, Array.from() 还可以对现有数组进行浅拷贝

2. 第二个参数是可选的音色函数参数, 类似数组的map方法, 直接创造一个映射后的数组 `p140`

3. 第三个可选参数是指定 映射函数参数的 this 值

**of()**

把一组参数参数转换为数组



#### 空位

> 用一串逗号创建空位

**ES6 新增方法将这些空位当成存在的元素, 只不过值是 undefined**, 而 之前的方法则会忽略这个空位

最佳实践: 避免使用空位数组, 如果要用, 需要显式的将空位用 undefined 代替



#### 索引

1. 通过修改 数组length 可以动态的实现数组的扩展和截取, 增大 length就用空位填补数组, 缩小length就截取数组
2. length 的变化是实时的

#### 数组检测

1. 在只有一个全局上下文时候可以使用 arr instanceof Array 来进行检测, 有多个全局上下文(多个框架), 由于存在不同全局上下文互相传值, 导致数组构造函数(指向)不一, 可能会导致判断失败
2. **Array.isArray()**  解决了上面的问题, 这个方法就是确定一个值是否是数组, 不管有几个全局上下文

