# 阴

> 虽然很开心的买了亿图 , 但是不要为了画脑图而去画脑图, 这个是框架辅助型工具, 主线还是要记好, 我之前探索的通过网页加 Markdown 更加适合有规律性的可重复性的复习
>
> 不过用脑图和流程图辅助学习也是良方
>
> 不要喧宾夺主

# 学习了 

## let

**和 var 的区别**

1. let 声明是块级作用域, var 是函数作用域

2. 只有 var 可以重复声明, 其他声明方式 (重复 let, var-let 混合声明都是不对的, 会报错)

   ```js
   1. chrome 最新 edge 重复 let 声明不会报错
   2. safari 重复 let 会报错
   ```

3. let 声明不会在作用域被提升

   1. 解析代码时 **JavaScript 引擎会注意到 let 声明, 但是在声明前不可以以任何方式来引用未声明的变量**, 在let 被声明的执行瞬间被称作**暂时性死区**, 此时应用后面才声明的代码会抛出错误

4. let 在**全局作用域中声明的变量不会成为 window 对象的属性** var 则会

5. let 不要依赖条件声明, 条件声明是一种反模式, 程序会更加难理解, 如果你发现自己在使用这种模式, 一定有更好的替换方案

6. for 循环中的 let

   1. 通过 let 进行 for 循环, JavaScript 引擎后台会为每个迭代循环**声明一个新的迭代变量** , 这个新的迭代变量 存在于 每个迭代循环的块级作用域中, 这种方式, 适用于所有的 for 循环 for-of for-in
   2. var声明的迭代变量会泄露到 for 循环的外面去



## const

1. const 声明时必须同时初始化变量, 尝试修改 该变量会报错
2. 这个限制只适用于它指向变量的引用 (**也就是不要改变对象的引用, 修改对象的内部属性并不会影响**)
3. 不可用 const 来声明迭代变量
4. **但是 对于 for-of for-in 循环特别有意义 -> 每次迭代都会创建一个新的变量**



## 风格和实践

1. 不要使用 var, 使用 let const, **可以明确作用域, 声明位置, 以及不变值**
2. 优先 const, let 次之
   1. 使用 const 可以让静态代码分析工具发现不合法的赋值操作, 提前发现错误
   2. 只在提前预知 变量会更改的情况下使用 let
   3. 这样可以让开发者更加有信心推断哪些值永远不会变, 也方便后期 debug 非预期行为



## 数据类型

> 一共有 7 种数据类型

1. 简单数据类型
   1. Undefined 
   2. null
   3. Boolean 
   4. string
   5. Symbol  (es6 新增)
   6. Number
2. 复杂数据类型
   1. 对象 Object (万物皆是对象)

### undefined

1. 声明但未初始化: 相当于默认赋值 undefined
2. ES3 增加这个值得目的: 区分对象空指针 (null) 和 未初始化变量的区别
3. **对于没有声明变量 有用的操作符只有一个 typeof** 其他方式调用 都会报错 此时 typeof 该值返回的是 undefined  (delete 虽然不报错, 但是无意义:  严格模式报错)
4. 建议声明变量时候初始化值, 这样方便和未声明值进行区分
5. undefined 是假值
6. 判断 是不是 undefined : `typeof param === 'undefined'`