# 多云

> 肃身边之气, 慎言, 独善其身, 出淤泥而不染, 少玩手机, 摆脱社交依赖



# 学习了

## 字符串方法 p123

1. indexOf, lastIndexOf

   1. `indexOf` 从头开始查询子字符串, `lastIndexOf` 从字符串末尾开始查找子字符串
   2. 两个方法都可以传入第二个参数, 指从哪个位置开始查找

2. Es6 : includes, startsWith, endsWith

   > 这是ES6新增的 3 个方法, 都会在字符串中搜索传入的子字符串, 并且返回一个布尔值

   三个方法含义都如字面意思

   `startsWith`  和  `includes` 都可以接受可选的第二参数, 表示开始搜索的位置

   `endsWith` 表示应该当做字符串末尾的位置

3. trim

   > 创建一个新的字符串, 并删除前后的空格

   如果只删除左边 (右边) 的空格字符串, 可以分别使用 `trimLeft` (`trimRight`)

4. repeat 

   > 接受一个数字, 将该字符串重复数次之后, 返回重复之后拼接的结果

5. padStart, padEnd

   > 这两个方法都会负值字符串

   1. 传参小于字符串长度: 则在对应的一边填充字符, 直到满足长度, 第一个参数是字符长度, 第二个参数是填充字符串, **默认填充字符是空格** 

6. 解构

   > 字符串原型上暴露了一个 `@@iterator` 方法, 用来表示可以迭代字符串的每个字符串 `p124`

   由于存在这个迭代属性`Symbol.iterator` (存在于实例的 `__proto__` 上), 可以进行两个操作

   1. 用 `for...of` 遍历
   2. 使用解构操作符进行解构

7. toLowerCase, toUpperCase, toLocaleLowerCase, toLocaleUpperCase

   > 在不知道涉及转换什么语言的时候用 `toLocaleLowerCase`  和 `toLocaleUpperCase` , 其他情况用 ,前两种

8. match

   > 本质上和正则的 `exec` 方法一样, 接受一个参数, 可以是正则表达式字符串(不报错正则的两条斜杠), 也可以是一个正则对象

   1. 返回值, 第一个元素是完美匹配的字符串, 随后的就是捕获到的捕获组的字符串

9. search  返回索引

   > 接受一个正则字符串或者正则, 返回第一个匹配位置的索引, 没有匹配到就返回 `-1`

10. replace

    1. **第一个参数可以是正则或字符串(此字符串不会被转换成正则)**
    2. 如果是一个字符串, 那就用第二个参数替换第一个匹配的字符串, 要相匹配所有子字符串, **第一个参数必须是正则并且带全局标志**
    3. 第二个参数可以是一个字符串, 有几个特殊的字符串要注意 `$1` `p126`
    4. 也可以是一个函数, **会接受到至少三个参数 (没有捕获组)**, 1. 与整个模式匹配的字符串 2. 匹配项在字符串中开始的位置 3. 整个字符串
    5. 在有多个捕获组的情况下, 头一个项不会变, 末两个项也不会变, 所有的捕获到的参数会插入到 1, 2之间
    6. 这个函数应该要返回一个字符串, 表示要替换成什么

11. split

    > 根据传入的分隔符, 拆分成数组

    1. 分隔符可以是字符串也可以穿入正则对象 (字符串不会转成正则)
    2. 还可以传入第二个参数, 就是数组大小, 可以限制数组的大小

12. localeCompare

    > 比较两个字符串, 返回 3个值中的一个, 根据地区, 决定这个方法如何比较字符串

    1. 如果按照字母表, 字符串应该排在参数前面, 就返回负值
    2. 相等就返回 0
    3. 字符串排在参数后面, 返回正值

13. 生成html的标签方法

    1. 早期认为用 `JavaScript` 生成标签是一个需求, 所以有许多通过 字符串 生成标签的方法, 详见 `p128`

    



## 单例内置对象

> 由 ECMAScript 实现, 与实现无关, 在程序开始之前就存在的对象, `Object, Array, String` 都是内置对象, `Global Math` 也是

### Global

> **最特别的对象, 因为代码不会显示的访问它, 是一个兜底对象** 他所针对的是**不属于任何对象的属性和方法**, 实际上不存在全局变量, 函数, **所有在全局作用域定义的变量和函数, 都会变成 Global 的对象的属性,** `isNaN, isFinite, parseInt, parseFloat` 都是Global 的方法

**encodeURI**

1. 一般用来对整个 URI 进行编码, 用URI 编码方式编码 URI 可以让浏览器能够理解, 同时又以 UTF-8 字符替换掉无效字符
2. 不会编码属于 URL 的特殊字符 如: `# : / ?`
3. 一般只会空格

**encodeURIComponent**

1. 用于编码URI 中单独的组件
2. 编码所有发现的非标准字符包括 `# : / ?` 以及额外的非标准字符
3. 通常使用频率更高, 因为通常用来编码长训字符串参数, 比较常用

**decodeURI**

1. 解码对应上面encodeURI编码的字符

**decodeURIComponent**

1. 解码对应上面encodeURIComponent编码的字符

**eval()**

> 最强大的功能, 这就是一个完整的 ECMAScript 解释器, 接受一个要执行的 ECMAScript 字符串

1. 调用时候, 将参数解释为实际的 ECMAScript 语句
2. 调用的代码, 属于当前上下文, 拥有和正常代码一样的作用域链, eval 中可以使用外部变量, **eval中定义的变量外部可以使用 (严格模式不可以),** 
3. **eval 声明的变量不会提升, 因为在执行这个语句的时候, 他们只是一个字符串, 在执行时才被创建**
4. 严格模式下, 赋值给 eval 会导致报错
5. 使用eval必须慎重, 特别是用户输入的内容, 会对 XSS 利用暴露很大的攻击面, 恶意用户会插入导致你网站崩溃