# 晴天

1. 早晨是要绝对专注的, 和时间融为一体, 互相印刻, 和时间建立联系
2. 乱七八糟的讯息确实会扰乱思维, 要是想保持思维干净, 没有杂念, 还是要少关注点东西
3. 工作好好整理思路, 不要老看手机, 会让人变得浮躁
4. 要想内心平和, 淡然愉悦, 就要少干扰, 简单生活



# 学习了

## 迭代器

### 自定义迭代器

1. 任何实现了 Iterable 接口的对象都可以用作迭代器 **p188**
2. 创建一个 Array 实例
   1. `arr[Symbol.iterator]() `返回的迭代器也拥有` [Symbol.iterator]`方法
   2. 并且该方法执行的结果执行的结果指向了第一个迭代器本身
   3. 换言之: 调用数组迭代器`let iter1 = arr[Symbol.iterator]` 的 `[Symbol.iterator]` 方法其实也是返回 `iter1` 自身
3. 在自定义的迭代器中, 可以定义一个 return ( ) 方法用于指定在迭代器关闭时执行的逻辑, 到底哪些方法可以 **关闭** 自定义迭代器呢
   1. for-of 循环的 break, continue, return 或 throw提前推出
   2. 结构操作没有消费所有值
   3. 这些操作都会调用定义的 return ( ) 方法
4. **正是 return ( ) 方法是可选的, 所以不是所有迭代器都支持关闭**, 可以测试迭代实例的 return 属性 是不是一个 **函数**, 不可以简单地给不可关闭的迭代器增加这个方法就让他变得可关闭, 虽说可以被调用, 但是却不会强制让迭代器关闭 **p191**
5. 比如数组的迭代器就没有默认关闭的功能



## 生成器

> 这是 ECMAScript 新增的一个极为灵活的结构, 可以在一个函数块内暂停恢复代码执行 (函数执行上下文的挂起和恢复执行)

**需要强调的是, 迭代对象包括了许多, 而生成器对象知识其中一种**

* 生成器的形式就是一个函数, 在函数名称前加上一个 ( * ) 号就表示这是一个生成器函数, 但凡可以定义函数的地方就可以定义生成器函数 ( 箭头函数除外 )

  ![image-20210916130650246](/Users/chenmingming/Library/Application Support/typora-user-images/image-20210916130650246.png)

* 标识生成器函数的 **星号** 不受两侧空格数量的影响, 空格请随意

* 调用生成器函数会得到一个 **生成器对象 ( 迭代器 )** , 其一开始时处于 **暂停 ( suspended )** 状态, 这个对象实现了 Iterator 接口, 调用 next ( ) 方法会让生成器开始或者恢复执行

* 调用 next ( ) 方法返回一个具有 done 和 value 属性的对象

* **生成器只会在初次调用 next ( ) 才开始执行**

## yield

> 这个关键字可以让生成器停止和开始执行, 生成器的核心关键字 **p194**

- 在遇到 yield 之前生成器函数会正常执行, 一旦遇到就会停止, 此时函数作用于状态会被保留
- 此时只要再次执行 next ( ), 就可以恢复执行
- next ( ) 执行之后会返回一个对象
- 通过 yield 退出的会返回 : done: false 状态
- 通过 return 退出的会返回: done: true 状态
- yield 必须直接位于生成器函数定义中



> 显示的调用 next ( ) 没什么用, 通常把生成器对象当成迭代对象来使用

1. 除了第一个 next ( ) 用于开启迭代器, 其余的 next ( ) 参数, 会交给上一个 yield 的结果
2. Array.from ( ) 可以将一个迭代器转换为一个数组



### 用 * 号增强 yield

这样他就可以迭代一个可迭代对象, 一次产出一个值, **yield 后面 * 号的空格也是随意的**

yield* 实际上将可迭代对象序列化为一连串可以单独产生的值, yield* 返回的值是 **迭代器返回 done 是 true 的 value 值**

yield* 最有用的是实现递归, 此时生成器可以产生自己以进行递归 **p199**



![image-20210916210329377](https://raw.githubusercontent.com/mannixchan/Pics/master/img/image-20210916210329377.png)



