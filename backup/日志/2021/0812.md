# 阴 -> 小雨

> 还是会受到太多没必要的讯息, 会影响心情, 少摄入无效讯息, 内心平和, 怡然自得

# 学习了

## 事件队列 - 事件循环

> 对于长时间不响应任务, 我们可以分解成不阻塞的小任务

1. **事件循环不仅仅包含事件队列, 而且至少两个队列** 除了事件之外, 还需要保存浏览器执行的其他操作(被称作任务): **宏任务 微任务**
2. 宏任务例子: 代表离散的, 独立工作单元
   1. 创建主文档对象
   2. 解析 HTML
   3. 执行主线(全局) JavaScript
   4. 更改 URL
   5. 以及各种事件
3. 微任务: 更小的任务, 必须在浏览器继续执行其他任务之前执行, 包括: 渲染页面UI, 宏任务
   1. promise
   2. dom 变化
   3. 微任务可以让我们在重新渲染 ui 之前执行指定的行为, 避免不必要的 UI 重绘(这会导致程序状态不连续)
4. es 官方没有提到事件循环, html 规范中有提到, es 规范只提到 处理 promise 回调, 虽然只有 html 规范定义了事件循环, 但是其他环境 如: Node.js也在使用它
5. 事件循环的实现至少应该包含一个宏任务队列和一个微任务队列, 当然会有更多的不同实现视情况而定

### 事件循环准则

1. 一次只处理一个任务
2. 任务执行中不会被其他任务中断
3. 事件循环从检查宏任务队列开始
4. 执行完当前宏任务 -> 事件循环去处理微任务队列
5. 处理完所有的微任务 -> 渲染 UI 继续下一轮

:speech_balloon: 单次事件循环 **最多处理一个宏任务, 而队列中的所有微任务都会被处理掉**

6. 当微任务队列清空, 事件循环会检查是否需要更新 UI .是, 就开始重新渲染 UI 至此一轮事件循环结束, 之后回到最初第一个环节 

![image-20210812230751155](https://raw.githubusercontent.com/mannixchan/Pics/master/img/image-20210812230751155.png)

### 注意点

1. **任务队列的检查和添加行为是独立于事件循环**的, 如果不这样设计, 发生的事件就会被忽略
2. 一个任务开始, 在完成前, 都不会被其他任务中断, 除非浏览器因为 执行时间过长, 占用内存过大中断
3. 所有微任务都会在下一次渲染之前完成, 因为微任务的目标就是在渲染之前更新程序状态
4. 浏览器通常会尝试每秒渲染 60 帧页面, 大概每隔 16ms 刷新一次, **在页面渲染时, 任何任务都无法再进行状态修改** 理想状态下, 单次事件循环都要在 16ms 内完成

### 页面渲染, 进入下一轮循环迭代

1. 提前在 16ms 前结束, 如果没有显式指定页面渲染, 浏览器可能不会选择在当前循环中 进行 UI 渲染
2. 大约在 16ms 时候执行到渲染 UI阶段, 这时候, 浏览器会执行 UI 更新让用户感觉流畅
3. 在 16ms 之后, 超过 16ms , 浏览器无法以目标帧率重新渲染页面,  页面就无法被及时更新, 这个时候就可以将复杂的任务分解为不阻塞的小任务 (优化)



### 包含宏任务微任务的实例

> 见下图

1. 全局js 在宏任务队列执行
2. 此期间发生的事件, 不会中断任务, 而是会被添加到宏任务队列
3. 第一次点击事件出发了立即兑现的promise, promise(完成)的回调不会立即执行
4. 而是会被插入到微任务队列
5. 此时在执行完第一次事件时候, 不会去执行第二次事件, 而是会把当前微任务队列的所有任务 (promise), 执行完毕, 渲染页面后才会去执行第二次点击事件
6. 再次强调几点
   1. 一个任务一旦开始, 无法被中断
   2. 事件监测和添加是独立于事件循环之外, 哪个队列的任务都不会耽误向事件队列添加任务
   3. 事件会等待主线任务执行完毕, 不会干扰主线任务执行 同1
   4. 微任务对比宏任务有优先执行权, 需要尽快的执行
   5. **每当执行完一个任务, 事件循环总是会先检查微任务队列**
   6. 微任务执行完成之前, 不允许重新渲染页面
   7. 无法在微任务之前添加微任务, 在之后

![image-20210812230718055](https://raw.githubusercontent.com/mannixchan/Pics/master/img/image-20210812230718055.png)

