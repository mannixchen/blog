# 阴雨 -> 连着好几天

> 休息肯定是要好好休息的, 休息好了身体状态好, 做事情也才会有精神
>
> 能够给自己生活学习都带来满足感
>
> 关于学习, 不是想着怎么去 successful, 而是要寻找内心的那份宁静和满足感哦
>
> **和时间建立联系哦**

# 学习了

## 正则

> 正则表达式语言是 mini 语言, 内置在了其他语言内

1. 匹配普通文本 (plain text)

   1. 直接写上对应的文本即可 `/ben/`
   2. js 里面默认只会匹配一个第一个结果, 需要全局匹配要加 g 如: `/ben/g`
   3. **正则匹配区分大小写** 取消默认可以加 i 如 : `/ben/i`

2. 匹配任意单个字符 `.` 字符, 如果匹配点自身: `\.`

   1. 这类特殊字符 (字符集) 用来表示要搜索的特定字符
   2. pattern (模式)
   3. `\` 是一个元字符, 表示 **这个字符有特殊含义, 代表的不是字符本身**, 匹配 `\` 自身, 就需要自己给自己转义 `\\`
   4. 在大多数正则实现里面,  `.` 不能匹配换行符

3. 匹配一组字符, 字符集合

   1. 在`[]` 中放入需要匹配的字符, 匹配其中之一, 中间不需要符号

   2. `[]` 不匹配任何字符, 符号本身只负责定义一个字符集合

   3. ```js
      /[0123456789]/ 同 /[0-9]/
      /[A-Z]/: 从 A 到 Z 的所有大写字母
      /[a-z]/:从 a 到 z 所有小写
      /[A-z]/:从 ASCII字符 A 到 z 的所有字符, 也包括一些 Z 到 a之间的特殊符号
      ```

   4. 区间 首字符要小于尾字符

   5. 可以连写: `[0-9a-zA-Z]`

4. **排除**: 在`[`后面接上 `^` 表示排除该字符集合, 除了该字符集合之外的任何字符都会得到匹配

      1. `^` 作用于字符集合里面的所有字符或字符区

   5. 元字符需要转义

      1. 元字符是正则里面有着特殊函数含义的字符 如: `.[]\{}`等
      2. 由于他们无法代表自身, 所以要 `\` 转义

  6. 空白字符的匹配

      1. window 匹配的文本行结束 为 `\r\n`
      2. 类 Unix 系统匹配的文本行结束标记是 `\n`
      3. `\r` 回车符 `\n` 换行符

  7. 类元字符匹配某一类字符 

      1. 匹配数字 : `\d`, `\D` 为匹配非数组
      2. 匹配字母数字以及`_`: `\w`    匹配字母数字以及`_`之外的值: `\W`
      3. 匹配 空白字符: `\s` 非空白字符: `\S`

   8. 重复匹配

       1. 匹配一个或多个 : `+`
       2. 匹配0或多个 : `*`
       3. 匹配 0 或 1个: `?`
       4. 匹配重复范围
          1. `{1,5}` : 1-5次
          2. `{5}` : 5次
          3. `{5,} ` : 5次以上

  9. 一般来说当在字符集合中使用像 `.+` 这样的元字符, 将会被解释成普通字符, 不需要转义, 但转义没坏处

  10. **过度匹配** p50

       1. 量词: `+*?` 都是量词, 匹配模式都是 **贪婪的** 他们会尽可能匹配出更多的字符
       2. 如果想匹配出尽可能少的字符需要在 **量词** 后面加上一个 `?` 
       3. 如: `*?` `+? ` `{n,}?`

  11. 位置匹配

       1. 单词边界 `\b`
       2. 非单词边界 `\B`
       3. `\b` 匹配字符之间的一个位置, 一边是单词 (\w 所能匹配到的字符), 另一边是其他内容()\W所匹配的字符)
       4. 字符串边界 
          1. **^** 表示字符串开头
          2. **$** 表示字符串结尾

   12. 子表达式

       1. `()` 括起来的呢绒是子表达式, 被视为单一的实体
       2. 子表达式可以用来分组
       3. `|` 操作符的使用,表示二者其一
       4. 子表达式内部依然可以嵌套, 子表达式里面套子表达式
       5. 理解子表达式关键在于每次只分析一个子表达式, 由内而外的看, 而不是从头开始, 远没有看上去复杂