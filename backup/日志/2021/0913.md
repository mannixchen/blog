# 台风天-灿都

应该面向需求去寻找软件

> 当有需求了，面向需求去寻找软件，**不要为了找软件去找软件**

**所以与其不知疲倦的去寻找软件，不如去探索自己的需求，根据需求去寻找软件**

任何脱离了上诉原则的找软件行为都是作贱时间，闲得慌

* 许多专业需求都由专业软件垄断，这些软件直接买就好了

* 而那些非大型工作软件，只需要根据需要进行购买就行了 ， **一定要记得先发现需求再去购买**

像我现在基本没有什么额外需求

我的需求基本都可以通过免费开源的软件达到要求

**观念一定要变**: **软件用的舒服就好啦，要公平公正的看他们，收费的不一定有免费的香（好用**)

结论是

就我目前的学习环境，我没有别的需求，我觉得很好用，根本不用添置任何其他软件

毕





# 学习了

## Map

> ES6 新增特性, 是一种新的集合类型, 为这门语言带来真正的 **键/值存储机制**

两者存在一些细微的差异, 具体实践中用哪个, 还是值得甄别

### api

1. 创建一个初始化的 Map 类型的时候, 可以传入一个可迭代对象, 里面包含包括键值的数组, 所谓可迭代对象, 就是拥有 `[Symbol.iterator]` 属性的对象 `p164`
2. 初始化之后可以使用 **`set`** 方法再次添加键值对, 
   1. set 方法会返回映射实例, 所以 **可以把多个操作连缀起来, 包括初始化声明**
3. 另外还可以使用 get ( ) 和 has ( ) 来进行对 Map 类型的查询操作
4. 用 size 属性 来获取键值对的数量
5. 使用 delete ( ) 和 clear ( ) 来删除值

> 和数组不同的是 **键可以使 JavaScript 中的任何数据类型**

### 顺序和迭代

> Map 类型会维护键值对的插入顺序, 所以会根据插入顺序

**Map** 数据类型提供了一个迭代器, 按照插入顺序生成了一个 `[key, value]` 形式的数组, 可以通过 实例的 `entries` 方法获取这个迭代器, 实例的 `[Symbol.iterator]` 实则也是引用的这个这个方法获取的迭代器

- 可以对 Map 数据类型进行展开操作



### 选择 Object 还是 Map

> 对于大部分 Web 开发任务来说, 选择两者只是偏好问题, 不过对于在乎内存和性能的开发者, 可以注意以下差别

1.  对于固定的内存大小,  Map 大约可以比 Object 多存储 50% 的键值对
2. 插入性能 Map 数据类型性能会快一点 (尤其是大量出入作用)
3. 查找速度, 两者差异小, 某些情况下可能 Object 更好
4. 删除性能,  Map 的 delete 效率会更高



## WeakMap

> weak 指的是 JavaScript 垃圾回收机制对待该类型键的方式, 键值不会干扰整个 JavaScript 环境中的垃圾回收 p170

弱映射类型的键只能是 Object 类型 , **尝试使用非对象设置键会报出 TypeError**

因为 WeakMap 中的键值对, 随时可能会被垃圾回收掉, 所以没有必要提供迭代键值对的能力, **所以必须要知道对象的引用, 才能从弱映射中获取值**

**弱映射可以实现真正的私有变量** 

> p 171, 看的迷糊, 不知其所以然

**DOM 节点元数据**



## Set

> 像是加强版的 Map, 好多 api 都是共有的

1. 构造函数可以直接传入一个 **可迭代对象**, 里面需要包含插入到新实例的元素
2. add 增加值 has ( ) 查询值, size 取得元素数量, delete ( ) , clear ( ), 可以删除元素
3. add ( ) 可以返回 Set 实例, 所以可以作为链式调用
4. delete ( ) 会返回一个 **布尔值**, 表示集合中是否存在要删除的值